%DP.m 
function [X_opt,Z_opt,fval,p,b,mf_sum,a,time_sum]=DP1(v0,v_max,v_min,v_ref,d,S,h,alpha)
%85,90,80,85,0.1,2500,25,'G1','B1','P1','N1','Mf1'
% X_opt 该速度下对应的下一状态的最优速度  ,G_opt 最优档位   ,fval最优成本   ,p 油门
% b 刹车， mf_sum燃油消耗量
% d速度离散区间 ;  s总距离 ;  h相邻两个速度状态之间的距离
%%
%确定状态数，离散速度个数，将其表示为数组
h = 10;
row=round((v_max-v_min)/d)+1;
column=round(S/h)+1;%沿着距离分割，有多少列
x=nan*ones(row,column);
x(1,1)=v0;
epsilon = 8; %Rounding
%%
%坡度赋值
a = zeros(column,1);
dist100 = [0,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000,10100,10200,10300,10400,10500,10600,10700,10800,10900,11000,11100,11200,11300,11400,11500,11600,11700,11800,11900,12000,12100,12200,12300,12400,12500,12600,12700,12800,12900,13000,13100,13200,13300,13400,13500,13600,13700,13800,13900,14000,14100,14200,14300,14400,14500,14600];
slope = [0.0451481961771237,0.0315989572778989,-0.00809301515410578,-0.00895569277908287,-0.00615836472963579,0.00204553882024943,0.00749605727066264,0.00425063927532914,0,0,-0.000775758992163063,-0.00689639254969777,-0.0147027943017154,-0.0170119934293256,-0.0170729237101843,-0.0120652526707926,0.00105886286586683,0.00569704864441519,0.00287700956542974,-0.00507544579827817,-0.00659655830035886,-0.00156074569386490,0,7.15732759329235e-05,0.00430908376457428,0.00899135663980946,0.00895805633197654,0.00889525321991709,0.00539675012852381,0.00462462929991677,0.0111409452050225,0.0155132842470795,0.0241164197337696,0.0246836307027451,0.0249720936626035,0.0250161447581147,0.0249441458930698,0.0224971262493265,0.0154974200329894,0.00325546510773698,-0.000899543495478739,-0.00978858833193129,-0.0166642666253717,-0.0247150913211619,-0.0249773787796824,-0.0248091985608734,-0.0242217559934659,-0.0176404665950432,-0.0100213325704840,-0.00479752975975977,-0.00501318125268785,-0.00212962250550323,-0.000699645015556634,0.000244347364156106,0.00575007891353518,0.00839554409850173,0.00656363637620860,0,0,0,0,0,0,0,0,-7.04982299842172e-05,-0.00744169651027171,-0.0109412130944417,-0.0147336940338613,-0.0148466931095925,-0.0128321509408632,-0.00909513563729858,-0.00575358280415507,-0.00338495404116149,-0.00567198551736018,-0.00597191082517968,-0.00669361185558243,-0.00569704864441526,-0.00402325575268602,0,0,0,0,0,0,0,0,0.000167605676445906,0.00469930520681700,0.00479752975975989,0.00309072543909277,0.00499742356816686,0.00491921015660614,0.00471256161602026,0.00529915400917110,0.00468266908221040,0.00105967099163355,-0.00559710253076665,-0.00483393760069655,0,0,0,0,-0.00528701858354845,-0.00579699464412904,-0.000619235361243096,0.00290208454924114,0.00444759699980153,0.00409789851294164,0.00379082509813111,0.00359815940942667,0.00496695129024026,0.00732150879604829,0.00922737816143176,0.00580570221256259,-0.00420318793436657,-0.0191691333745329,-0.0188686403128786,-0.0145139721493272,-0.0126073857231743,-0.0124930123820950,-0.00410889751488551,0.00172498754191848,0.00169913653561556,7.23832164172222e-05,-0.00609235973319125,0.00274761806908025,0.00999459728181188,0.00504427324813049,0,0.00231070957651667,0.0109546822576793,0.0113096053736247,0.0110315671974725,0.0109742032392742,-0.00109665244327008,-0.0312083808958549,-0.0407143944484384,-0.0392109097864292,-0.0390428885133146,-0.0158595228877454,0.00139000805183757,0.00179790451661344,0.00205930243878496,0.00231702029395739,0.00435284783645166,0.00417573761136874];
for k = 1:column
 for jj = 1:1:(size(dist100,2)-1)
     if (dist100(jj) < k*h) && (k*h <= dist100(jj+1))
         a(k) = slope(jj);
     end
 end
end
%%将速度离散化
for i=2:(S/h)
    x(:,i)=v_max:-d:v_min;
end
%%
%终端状态约束
v_last=v_max;
row_last=round((v_max-v_ref)/d)+1;%最后分离的速度有多少

for j=1:row_last
    if j == row_last
        x(j,column)=v_ref;
    end
end
%%
t_vubm=inf*ones(size(x));%与每个成本对比的无限大值
f_opt=nan*ones(size(x));%最优成本
x_opt=f_opt;%最优状态
z_opt=f_opt;%最优发动机on/off信号（离合器闭合/断开信号）
f_opt(:,column)=0;
% t_vubm(:,column)=0;
x_opt(:,column)=x(:,column);
%%
for i=1:row_last  %最后一列状态的最优档位为保持该速度下的最小燃油消耗率对应的档位
    p1=P1(x(i,column),x(i,column),a(column-1));
    if ((-30 - epsilon) <= p1 ) && (p1 <= (-30 + epsilon))
        z1 = 0;
        p1 = -30;
    else 
        z1 = 1;                    
    end
    n1=N1(x(i,column));
    mf1=Mf1(n1,p1,z1,x(i,column));
    tmp=mf1;
    if tmp<=t_vubm(i,column)
        z_opt(i,column)=z1;
        t_vubm(i,column)=tmp;
    end
end
%%
%逆推运算
% shift1 = column;
% shift = column;
for i=(column-1):-1:1 % 倒数第二列开始从后向前递推
    for j=1:row % 行的遍历
        if ~isnan(x(j,i))
            for k=1:row  % 从x(j,i)列到 x(:,i+1)列的每个state遍历
                b1=B1(x(j,i),x(k,i+1),a(i)); %制动
                p1=P1(x(j,i),x(k,i+1),a(i)); %驱动
                if ((-30 - epsilon) <= p1 ) && (p1 <= (-30 + epsilon))
                    z1 = 0;
                    p1 = -30;
                else 
                    z1 = 1;                    
                end
                if ((0<=p1)&&(p1<=120))||((0<=b1)&&(b1<=500))||(p1==-30)
                    n1=N1(x(j,i));
                    mf=Mf1(n1,p1,z1,x(j,i));
                    tmp=mf + f_opt(k,i+1) + alpha*abs(z1-z_opt(k,i+1));
%                     tmp=mf + f_opt(k,i+1);
                    if tmp<=t_vubm(j,i)
                        z_opt(j,i)=z1;
                        f_opt(j,i)=tmp;
                        x_opt(j,i)=x(k,i+1);
                        t_vubm(j,i)=tmp;
                    end
                end
            end
        end
    end
end
%%
X=x_opt;%该速度下对应的下一状态的最优速度
F=f_opt;
ZZZ=z_opt;%该速度下的最优档位
X_opt(1:column)=nan;
Z_opt(1:column)=nan;
X_opt(1)=x(1,1);%初始速度
X_opt(2)=X(1,1);%第二步速度
Z_opt(1)=ZZZ(1,1);%初始档位
%%
for i=2:(column-1)%从前向后依次寻找最优速度序列
    tmp2=x(:,i)-X_opt(i);
    tmp3=find(tmp2==0);
     X_opt(i+1)=X(tmp3,i);
end

for i=2:column%从前向后依次寻找最优档位序列
    tmp2=x(:,i)-X_opt(i);
    tmp3=find(tmp2==0);
    Z_opt(i)=ZZZ(tmp3,i);      
end

fval=f_opt(1,1);%最优成本
%%
for i=1:column-1%通过最优速度序列求解最优控制动作序列
    p(i)=P1(X_opt(i),X_opt(i+1),a(i));
    b(i)=B2(X_opt(i),X_opt(i+1),a(i),Z_opt(i));
    if p(i)>=0
        b(i)=0;
    else 
        p(i)=0;
    end
    if b(i) <= 0
        b(i) = 0;
    end
end
%%
mf_sum=0;%求解代价函数
for i=1:column-1
    n1=N1(X_opt(i));
    mf=Mf2(n1,p(i),Z_opt(i),X_opt(i));
    mf_sum=mf+mf_sum;
end
time_sum=0;%求解代价函数
for i=1:column-1
    time=h*3.6/X_opt(i);
    time_sum=time+time_sum;
end
%%
%作图
% heng=0:25:2500;G2=12;
% for i=1:101
% altitude(i)=25*sum(a(1:i-1));
% end
% x1=1:S;
% for i=1:S
%     j=ceil(i/25);
%     p2(i)=p(j);
%     b2(i)=b(j);
% end
% subplot(5,1,1)
% plot(heng,altitude,'LineWidth',2);ylabel('海拔[m]');title('2%');ylim([-15 15]);xlim([0 2500]);grid on;
% subplot(5,1,2)
% plot(heng,X_opt,'LineWidth',2);ylabel('速度[km/h]');ylim([80 90]);xlim([0 2500]);grid on;legend('MPC acc');
% subplot(5,1,3)
% plot(x1,p2,'LineWidth',2);ylabel('油门踏板水平P');ylim([0 1.1]);xlim([0 2500]);grid on;legend('MPC acc');
% subplot(5,1,4)
% plot(x1,b2,'LineWidth',2);ylabel('制动水平B');ylim([0 1.1]);xlim([0 2500]);grid on;legend('MPC acc');
% subplot(5,1,5)
% plot(heng,G_opt,'LineWidth',2);ylabel('档位');xlabel('位置[m]');ylim([10.9 12.1]);xlim([0 2500]);grid on;legend('MPC acc');    

end
